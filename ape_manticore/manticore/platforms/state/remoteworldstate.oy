from .worldstate import WorldState
from .storage import Storage
from typing import  Set, Union
from ...core.smtlib import (
    BitVec,
    ConstraintSet,
)
from ...exceptions import EthereumError
from ape.api import Web3Provider
from ape.exceptions import ContractLogicError, ProviderError, VirtualMachineError
from web3 import HTTPProvider, Web3
from web3.exceptions import ContractLogicError as Web3ContractLogicError
from web3.gas_strategies.rpc import rpc_gas_price_strategy
from web3.middleware import geth_poa_middleware

class RemoteWorldState(Web3Provider, WorldState):

    def is_remote(self) -> bool:
        return True

    def accounts(self) -> Set[int]:
        raise NotImplementedError

    def get_nonce(self, address: int) -> int:
        return self._web3().eth.getTransactionCount(_web3_address(address))

    def get_balance(self, address: int) -> int:
        return self._web3().eth.getBalance(_web3_address(address))

    def has_storage(self, address: int) -> bool:
        raise NotImplementedError

    def get_storage(self, address) -> Storage:
        raise NotImplementedError

    def get_storage_data(
        self, constraints: ConstraintSet, address: int, offset: Union[int, BitVec]
    ) -> int:
        if not isinstance(offset, int):
            raise NotImplementedError
        return int.from_bytes(self._web3().eth.getStorageAt(_web3_address(address), offset), "big")

    def get_code(self, address: int) -> bytes:
        return self._web3().eth.getCode(_web3_address(address))

    def get_blocknumber(self) -> int:
        return self._web3().eth.blockNumber

    def get_timestamp(self) -> int:
        return self._web3().eth.getBlock("latest")["timestamp"]

    def get_difficulty(self) -> int:
        return self._web3().eth.getBlock("latest")["difficulty"]

    def get_gaslimit(self) -> int:
        return self._web3().eth.getBlock("latest")["gasLimit"]

    def get_coinbase(self) -> int:
        return int(self._web3().eth.coinbase, 16)
